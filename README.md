


> 一个基于 ESP32-S3 的状态机菜单系统，使用 Arduino 框架和 U8g2 显示库。



## ✨ 特性

- ✅ **状态机架构** - 基于回调用户自定义函数的状态管理
- ✅ **灵活配置** - 支持动态菜单项和参数传递
- ✅ **低内存占用** - 采用静态分配，完全没有手动分配内存
- ✅ **易于扩展** - 简单的回调接口，快速添加新功能
- ✅ **U8g2 支持** - 内置 OLED 显示驱动
- ✅ **多级菜单** - 支持无限级嵌套（理论上）


## 📖 目录导航
- [✨ 特性](#✨ 特性)
- [🚀 快速开始(视频)](#🚀 快速开始)
- [🏗️ 项目结构](#项目结构)
- [🔧 API](#API)
  - [按键采集API](#按键采集API)
  - [显示输出API](#显示输出API)
- [📁 核心数据结构](#结构体)
  - [📁 核心数据结构:菜单与列表](#📁 核心数据结构：菜单与列表)
  - [🖥️ 核心数据结构:显示模块  ](#🖥️ 核心数据结构：显示数据包)
- [❓ 常见问题](#这个懒得写了，我先吃个饭)



## 🚀 快速开始

----[🚀 快速开始(视频)(还没做)](www.我还没做.com)





## 项目结构

- 项目结构如下
                  [数据管理结构体]
                        ↓
                  [ 内部API ]
                        ↑
    ┌───────────────────┼───────────────────┐
实时↑更新               ↓                   ↓
    ↑                   ↓                   ↓
┌───────┐         ┌───────┐             ┌───────┐
│  1.   │         │  2.   │             │  3.   │
│键盘模块          │菜单循 │             │显示模块
└───────┘         │环模块 │             └───┬───┘
                  └───┬───┘                 ↓
                      ↑                 ┌─────┐
                  ┌─────┐               │ 3.1 │
                  │ 2.1 │               │封装的
                  │回调 │               │显示API
                  │函数 │               └───┬─┘
                  └───┬─┘                   ↓
                      ↑                     ↓
                  ┌─────┐                   |
                  │2.1.1│◄───────调用───────┘
                  │用户 │
                  │接口 │
                  └─────┘






## API

- 只需要简单调用API就能输出图像
- 简单实现可以不主动调用u8g2

- 使用前，请先调用src里的menu_API.h
- 显示API必须结合本菜单的自定义结构使用

- 下面是API介绍



### 按键采集API

- 键盘模块支持自定义键位(详情见sitting.h)
- 支持自定义扫描函数(详情见src/keybord/user_defined.c)

定时器定时采集到的键值将被存入**数据管理结构体**,通过以下API可以得到键值
```c

uint8_t get_key_value();
//扫描数据管理，如果此时键盘键值非KEY_NULL，则记录键值，否则返回并销毁内部存储键值
//适用：单线程的单击检测
uint8_t get_press_time();//返回接口里的按键按下时间
uint8_t get_last_key();//扫描数据管理，返回一次键值

```



### 显示输出API

- 目前实现了：菜单和列表的显示
- 有一部分还没写完暂时用不了

- 强烈建议先看下面的**结构体**栏目，在这讲不清楚

显示模块用一种结构体包装了多种显示的信息，并且可以用链表叠加图层
```c

void u8g2_print_display_info( display_info *INFO );
//通用的打印函数，在参数INFO被正确填写的时候可以打印所有内容
//内部包含指针，可以组成链表

```


### 信息处理API

- 这一块都是数据处理的API
- 设置菜单光标，打印位置什么的API都在这


```c

bool do_nothing( void* do_nothing );//菜单里调用的空回调函数
display_info image_to_display_info( char IMAGE[1024] );//把图像转化为显示信息包并返回（实现中）
display_info config_menu_display_info(menu *MENU);//把menu类型包装打印信息返回
display_info config_list_display_info(list *LIST);//把list类型包装打印信息返回
bool set_menu_cursor( menu *MENU );//内部调用get_last_key(),检测单击并设置作为参数的菜单的光标，一个循环最好只调用一次
bool set_list_cursor( list *LIST );//功能类似上面这个
```




## 结构体 

### 🖥️ 核心数据结构：显示数据包

  （显示信息包）↓
**`display_info_t`**
     │
     ├─ **`mode`** (enum) ← 决定 data 联合体中哪个成员有效
     │
     ├─ **`data`** (display_data 联合体) ← 根据 mode 选择其中之一
     │   ├─ **`*str[64]`**        (当 mode 为 DISPLAY_MODE_INFO 时)
     │   ├─ **`*menu_t`**         (当 mode 为 DISPLAY_MODE_MENU 时)
     │   ├─ **`*img`**            (当 mode 为 DISPLAY_MODE_IMAGE 时) → 指向 image_t 结构
     │   └─ **`*list_t`**         (当 mode 为 DISPLAY_MODE_LIST 时)
     │
     ├─ **`x, y`** (坐标) ← 绘制起点，对 img、str 等类型生效
     │
     └─ **`*next`** ← 指向下一个显示信息包，实现图层叠加链表


#### `display_info` 结构体
- 此结构体是**显示信息的通用承载容器**
- 用于将任意需要在屏幕上绘制的内容（文字、图形等）及其样式（坐标、类型）打包
- 并通过链表结构支持**多层内容叠加**。

```c
//↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
/**
 * 显示信息节点结构体
 * @brief 核心的显示数据载体，以链表形式组织，实现图层管理。
 */
typedef struct display_info_t {
    PRINT_MODE mode;           // 【显示模式】决定如何解读下方的`data`联合体
    display_data data;         // 【显示数据】一个联合体，根据`mode`存放具体内容
    unsigned char x;           // 【屏幕X坐标】绘制起点的横坐标（单位：像素）
    unsigned char y;           // 【屏幕Y坐标】绘制起点的纵坐标（单位：像素）
    struct display_info_t *next; // 【链表指针】指向下一个节点，NULL表示链表结束
} display_info;
//↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑
```



### 📁 核心数据结构：菜单与列表

- 为了让菜单系统的逻辑清晰且易于扩展，我们定义了以下核心数据结构。
- 先来张容易看懂的图表


────交互菜单 `menu_t`
     ├─ `*name`       (菜单标题)
     ├─ `length`      (选项总数)
     ├─ `cursor`      (当前焦点选项索引)
     └─ `*menu_list`  (指向选项数组)
          │
          │
          └─ `option[]` (选项数组)
               ├─ `name`     (选项标签)
               ├─ `callback` (核心功能函数指针)
               └─ `param`    (传递给函数的参数)

────只读列表 `list_t`
     ├─ `*name`   (列表标题)
     ├─ `list[]`   (字符串数组，存储待显示的行)
     └─ `cursor`   (高亮行位置，用于视觉指示)

              



                **菜单**

#### 🗂️ `menu` 结构体：菜单单元
- 这是一个菜单的**完整信息**，包含了用户在菜单上看到的选项列表，光标位置，菜单title和长度

```c
//↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
/**
 * 菜单结构体
 * @brief 一个完整的菜单页面信息，包含标题、选项列表和光标状态。
 */
typedef struct menu_t {
    const char *name;     // 🏷️  菜单标题
    int length;           // 📏  菜单选项列表的长度（即有多少个option）
    unsigned char cursor; // 🎯  当前光标所在选项的索引（从0开始）
    option *menu_list;    // ☝️   指向option数组的指针（即菜单的选项列表）
} menu;
```

#### 🏗️ `option` 结构体：菜单选项单元
- 这是构成菜单的**最小单元**，定义了用户在菜单上看到的每一个选项及其调用的函数
```c
/**
 * 菜单选项结构体
 * @brief 代表菜单中的一个可选项，包含其名称和触发后的行为。
 */
typedef struct option_t {
    char name[40];           // 🔤 选项显示名称（屏幕上看到的文本）
    bool (*callback)(void*); // ⚙️  回调函数指针，选中此选项后执行的函数
    void* param;             // 📦 传递给回调函数的参数指针
} option;

//↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑
```


                **列表**

#### 🗂️ `list` 结构体：列表单元
- 这是构成单个列表的**完整信息**，定义了用户在列表上看到的每一行文本地址及其调用的函数

```c
//↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
/**
 * 列表结构体 (Text List)
 * @brief 用于显示一个简单的、以文字为主的垂直列表。
 */
typedef struct list_t {
    const char *name;       // 🏷️  列表标题
    unsigned char cursor;   // ➡️   当前首行位置（用于计算滚动）
    const char *list[64];   // 📄  字符串指针数组，存储所有要显示的行文本
} list;
//↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑
```